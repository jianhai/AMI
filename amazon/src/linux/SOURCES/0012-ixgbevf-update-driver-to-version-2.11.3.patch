From cb2b7966bd03b081e44222d374d235bec2f71a79 Mon Sep 17 00:00:00 2001
From: Cristian Gafton <gafton@amazon.com>
Date: Wed, 16 Oct 2013 05:25:25 +0000
Subject: ixgbevf: update driver to version 2.11.3

URL: http://sourceforge.net/projects/e1000/files/ixgbevf%20stable/2.11.3/
Signed-off-by: Cristian Gafton <gafton@amazon.com>
(cherry picked from commit 0fcbbbefc1603df74245ca66559723fd265a2bce)
Signed-off-by: Munehisa Kamata <kamatam@amazon.com>
---
 drivers/amazon/ixgbevf/ixgbe_type.h      | 44 ++++++++++-----------
 drivers/amazon/ixgbevf/ixgbevf.h         |  5 +--
 drivers/amazon/ixgbevf/ixgbevf_ethtool.c | 67 ++++++++++++++++++++------------
 drivers/amazon/ixgbevf/ixgbevf_main.c    | 41 ++++++++++++++++---
 drivers/amazon/ixgbevf/kcompat.h         | 35 ++++++++++++++---
 5 files changed, 131 insertions(+), 61 deletions(-)

diff --git a/drivers/amazon/ixgbevf/ixgbe_type.h b/drivers/amazon/ixgbevf/ixgbe_type.h
index 05b7baa..142abf0 100644
--- a/drivers/amazon/ixgbevf/ixgbe_type.h
+++ b/drivers/amazon/ixgbevf/ixgbe_type.h
@@ -1805,28 +1805,28 @@ enum {
 #define IXGBE_PBANUM_LENGTH	11
 
 /* Checksum and EEPROM pointers */
-#define IXGBE_PBANUM_PTR_GUARD	0xFAFA
-#define IXGBE_EEPROM_CHECKSUM	0x3F
-#define IXGBE_EEPROM_SUM	0xBABA
-#define IXGBE_PCIE_ANALOG_PTR	0x03
-#define IXGBE_ATLAS0_CONFIG_PTR	0x04
-#define IXGBE_PHY_PTR		0x04
-#define IXGBE_ATLAS1_CONFIG_PTR	0x05
-#define IXGBE_OPTION_ROM_PTR	0x05
-#define IXGBE_PCIE_GENERAL_PTR	0x06
-#define IXGBE_PCIE_CONFIG0_PTR	0x07
-#define IXGBE_PCIE_CONFIG1_PTR	0x08
-#define IXGBE_CORE0_PTR		0x09
-#define IXGBE_CORE1_PTR		0x0A
-#define IXGBE_MAC0_PTR		0x0B
-#define IXGBE_MAC1_PTR		0x0C
-#define IXGBE_CSR0_CONFIG_PTR	0x0D
-#define IXGBE_CSR1_CONFIG_PTR	0x0E
-#define IXGBE_FW_PTR		0x0F
-#define IXGBE_PBANUM0_PTR	0x15
-#define IXGBE_PBANUM1_PTR	0x16
-#define IXGBE_ALT_MAC_ADDR_PTR	0x37
-#define IXGBE_FREE_SPACE_PTR	0X3E
+#define IXGBE_PBANUM_PTR_GUARD		0xFAFA
+#define IXGBE_EEPROM_CHECKSUM		0x3F
+#define IXGBE_EEPROM_SUM		0xBABA
+#define IXGBE_PCIE_ANALOG_PTR		0x03
+#define IXGBE_ATLAS0_CONFIG_PTR		0x04
+#define IXGBE_PHY_PTR			0x04
+#define IXGBE_ATLAS1_CONFIG_PTR		0x05
+#define IXGBE_OPTION_ROM_PTR		0x05
+#define IXGBE_PCIE_GENERAL_PTR		0x06
+#define IXGBE_PCIE_CONFIG0_PTR		0x07
+#define IXGBE_PCIE_CONFIG1_PTR		0x08
+#define IXGBE_CORE0_PTR			0x09
+#define IXGBE_CORE1_PTR			0x0A
+#define IXGBE_MAC0_PTR			0x0B
+#define IXGBE_MAC1_PTR			0x0C
+#define IXGBE_CSR0_CONFIG_PTR		0x0D
+#define IXGBE_CSR1_CONFIG_PTR		0x0E
+#define IXGBE_FW_PTR			0x0F
+#define IXGBE_PBANUM0_PTR		0x15
+#define IXGBE_PBANUM1_PTR		0x16
+#define IXGBE_ALT_MAC_ADDR_PTR		0x37
+#define IXGBE_FREE_SPACE_PTR		0X3E
 
 #define IXGBE_SAN_MAC_ADDR_PTR		0x28
 #define IXGBE_DEVICE_CAPS		0x2C
diff --git a/drivers/amazon/ixgbevf/ixgbevf.h b/drivers/amazon/ixgbevf/ixgbevf.h
index 2dd0a41..92d25c7 100644
--- a/drivers/amazon/ixgbevf/ixgbevf.h
+++ b/drivers/amazon/ixgbevf/ixgbevf.h
@@ -96,8 +96,8 @@ struct ixgbevf_ring {
 /* How many Rx Buffers do we bundle into one write to the hardware ? */
 #define IXGBEVF_RX_BUFFER_WRITE	16	/* Must be power of 2 */
 
-#define MAX_RX_QUEUES 1
-#define MAX_TX_QUEUES 1
+#define MAX_RX_QUEUES IXGBE_VF_MAX_RX_QUEUES
+#define MAX_TX_QUEUES IXGBE_VF_MAX_TX_QUEUES
 
 #define IXGBEVF_DEFAULT_TXD   1024
 #define IXGBEVF_DEFAULT_RXD   512
@@ -252,7 +252,6 @@ struct ixgbevf_adapter {
 	struct ixgbe_hw hw;
 	u16 msg_enable;
 	struct ixgbevf_hw_stats stats;
-	u64 zero_base;
 
 	unsigned long state;
 
diff --git a/drivers/amazon/ixgbevf/ixgbevf_ethtool.c b/drivers/amazon/ixgbevf/ixgbevf_ethtool.c
index 2221a58..bede092 100644
--- a/drivers/amazon/ixgbevf/ixgbevf_ethtool.c
+++ b/drivers/amazon/ixgbevf/ixgbevf_ethtool.c
@@ -50,16 +50,27 @@
 #ifdef ETHTOOL_GSTATS
 struct ixgbe_stats {
 	char stat_string[ETH_GSTRING_LEN];
-	int sizeof_stat;
-	int stat_offset;
-	int base_stat_offset;
-	int saved_reset_offset;
+	struct {
+		int sizeof_stat;
+		int stat_offset;
+		int base_stat_offset;
+		int saved_reset_offset;
+	};
 };
 
-#define IXGBEVF_STAT(m, b, r) sizeof(((struct ixgbevf_adapter *)0)->m),	\
-		offsetof(struct ixgbevf_adapter, m),			\
-		offsetof(struct ixgbevf_adapter, b),			\
-		offsetof(struct ixgbevf_adapter, r)
+#define IXGBEVF_STAT(m, b, r) { \
+	.sizeof_stat = FIELD_SIZEOF(struct ixgbevf_adapter, m), \
+	.stat_offset = offsetof(struct ixgbevf_adapter, m), \
+	.base_stat_offset = offsetof(struct ixgbevf_adapter, b), \
+	.saved_reset_offset = offsetof(struct ixgbevf_adapter, r) \
+}
+
+#define IXGBEVF_ZSTAT(m) { \
+	.sizeof_stat = FIELD_SIZEOF(struct ixgbevf_adapter, m), \
+	.stat_offset = offsetof(struct ixgbevf_adapter, m), \
+	.base_stat_offset = -1, \
+	.saved_reset_offset = -1 \
+}
 static struct ixgbe_stats ixgbe_gstrings_stats[] = {
 	{"rx_packets",
 	 IXGBEVF_STAT(stats.vfgprc, stats.base_vfgprc, stats.saved_reset_vfgprc)},
@@ -69,15 +80,12 @@ static struct ixgbe_stats ixgbe_gstrings_stats[] = {
 	 IXGBEVF_STAT(stats.vfgorc, stats.base_vfgorc, stats.saved_reset_vfgorc)},
 	{"tx_bytes",
 	 IXGBEVF_STAT(stats.vfgotc, stats.base_vfgotc, stats.saved_reset_vfgotc)},
-	{"tx_busy",IXGBEVF_STAT(tx_busy, zero_base, zero_base)},
+	{"tx_busy", IXGBEVF_ZSTAT(tx_busy)},
 	{"multicast",
 	 IXGBEVF_STAT(stats.vfmprc, stats.base_vfmprc, stats.saved_reset_vfmprc)},
-	{"rx_csum_offload_good",
-	 IXGBEVF_STAT(hw_csum_rx_good, zero_base, zero_base)},
-	{"rx_csum_offload_errors",
-	 IXGBEVF_STAT(hw_csum_rx_error, zero_base, zero_base)},
-	{"tx_csum_offload_ctxt",
-	 IXGBEVF_STAT(hw_csum_tx_good, zero_base, zero_base)},
+	{"rx_csum_offload_good", IXGBEVF_ZSTAT(hw_csum_rx_good)},
+	{"rx_csum_offload_errors", IXGBEVF_ZSTAT(hw_csum_rx_error)},
+	{"tx_csum_offload_ctxt", IXGBEVF_ZSTAT(hw_csum_tx_good)},
 };
 
 #define IXGBE_QUEUE_STATS_LEN 0
@@ -271,8 +279,10 @@ static void ixgbevf_get_regs(struct net_device *netdev, struct ethtool_regs *reg
 
 	regs->version = (1 << 24) | hw->revision_id << 16 | hw->device_id;
 
+	/* IXGBE_VFCTRL is a Write Only register, so just return 0 */
+	regs_buff[0] = 0x0;
+
 	/* General Registers */
-	regs_buff[0] = IXGBE_READ_REG(hw, IXGBE_VFCTRL);
 	regs_buff[1] = IXGBE_READ_REG(hw, IXGBE_VFSTATUS);
 	regs_buff[2] = IXGBE_READ_REG(hw, IXGBE_VFLINKS);
 	regs_buff[3] = IXGBE_READ_REG(hw, IXGBE_VFRXMEMWRAP);
@@ -516,19 +526,26 @@ static void ixgbevf_get_ethtool_stats(struct net_device *netdev,
 				      struct ethtool_stats *stats, u64 *data)
 {
 	struct ixgbevf_adapter *adapter = netdev_priv(netdev);
+	char *base = (char *) adapter;
 	int i;
 
 	ixgbevf_update_stats(adapter);
 	for (i = 0; i < IXGBE_GLOBAL_STATS_LEN; i++) {
-		char *p = (char *)adapter + ixgbe_gstrings_stats[i].stat_offset;
-		char *b = (char *)adapter + ixgbe_gstrings_stats[i].base_stat_offset;
-		char *r = (char *)adapter + ixgbe_gstrings_stats[i].saved_reset_offset;
-		data[i] = ((ixgbe_gstrings_stats[i].sizeof_stat ==
-			    sizeof(u64)) ? *(u64 *)p : *(u32 *)p) -
-			  ((ixgbe_gstrings_stats[i].sizeof_stat ==
-			    sizeof(u64)) ? *(u64 *)b : *(u32 *)b) +
-			  ((ixgbe_gstrings_stats[i].sizeof_stat ==
-			    sizeof(u64)) ? *(u64 *)r : *(u32 *)r);
+		char *p = base + ixgbe_gstrings_stats[i].stat_offset;
+		char *b = base + ixgbe_gstrings_stats[i].base_stat_offset;
+		char *r = base + ixgbe_gstrings_stats[i].saved_reset_offset;
+
+		if (ixgbe_gstrings_stats[i].sizeof_stat == sizeof(u64)) {
+			if (ixgbe_gstrings_stats[i].base_stat_offset >= 0)
+				data[i] = *(u64 *)p - *(u64 *)b + *(u64 *)r;
+			else
+				data[i] = *(u64 *)p;
+		} else {
+			if (ixgbe_gstrings_stats[i].base_stat_offset >= 0)
+				data[i] = *(u32 *)p - *(u32 *)b + *(u32 *)r;
+			else
+				data[i] = *(u32 *)p;
+		}
 	}
 }
 
diff --git a/drivers/amazon/ixgbevf/ixgbevf_main.c b/drivers/amazon/ixgbevf/ixgbevf_main.c
index 2bc76de..29f4a15 100644
--- a/drivers/amazon/ixgbevf/ixgbevf_main.c
+++ b/drivers/amazon/ixgbevf/ixgbevf_main.c
@@ -60,7 +60,7 @@ char ixgbevf_driver_name[] = "ixgbevf";
 static const char ixgbevf_driver_string[] =
 	"Intel(R) 10 Gigabit PCI Express Virtual Function Network Driver";
 
-#define DRV_VERSION "2.10.3"
+#define DRV_VERSION "2.11.3"
 const char ixgbevf_driver_version[] = DRV_VERSION;
 static char ixgbevf_copyright[] = "Copyright (c) 2009-2012 Intel Corporation.";
 
@@ -1479,20 +1479,30 @@ static int ixgbevf_configure_dcb(struct ixgbevf_adapter *adapter)
 	struct ixgbe_hw *hw = &adapter->hw;
 	unsigned int def_q = 0;
 	unsigned int num_tcs = 0;
+#ifdef HAVE_TX_MQ
+	unsigned int num_rx_queues = adapter->num_rx_queues;
+	unsigned int num_tx_queues = adapter->num_tx_queues;
+#else
 	unsigned int num_rx_queues = 1;
+#endif
 	int err;
 
-	spin_lock(&adapter->mbx_lock);
+	spin_lock_bh(&adapter->mbx_lock);
 
 	/* fetch queue configuration from the PF */
 	err = ixgbevf_get_queues(hw, &num_tcs, &def_q);
 
-	spin_unlock(&adapter->mbx_lock);
+	spin_unlock_bh(&adapter->mbx_lock);
 
 	if (err)
 		return err;
 
 	if (num_tcs > 1) {
+#ifdef HAVE_TX_MQ
+		/* we need only one Tx queue */
+		num_tx_queues = 1;
+#endif
+
 		/* update default Tx ring register index */
 		adapter->tx_ring[0].reg_idx = def_q;
 
@@ -1501,7 +1511,12 @@ static int ixgbevf_configure_dcb(struct ixgbevf_adapter *adapter)
 	}
 
 	/* if we have a bad config abort request queue reset */
+#ifdef HAVE_TX_MQ
+	if ((adapter->num_rx_queues != num_rx_queues) ||
+	    (adapter->num_tx_queues != num_tx_queues)) {
+#else
 	if (adapter->num_rx_queues != num_rx_queues) {
+#endif
 		/* force mailbox timeout to prevent further messages */
 		hw->mbx.timeout = 0;
 
@@ -1986,19 +2001,35 @@ static void ixgbevf_set_num_queues(struct ixgbevf_adapter *adapter)
 	adapter->num_rx_queues = 1;
 	adapter->num_tx_queues = 1;
 
-	spin_lock(&adapter->mbx_lock);
+	spin_lock_bh(&adapter->mbx_lock);
 
 	/* fetch queue configuration from the PF */
 	err = ixgbevf_get_queues(hw, &num_tcs, &def_q);
 
-	spin_unlock(&adapter->mbx_lock);
+	spin_unlock_bh(&adapter->mbx_lock);
 
 	if (err)
 		return;
 
 	/* we need as many queues as traffic classes */
+#ifdef HAVE_TX_MQ
+	if (num_tcs > 1) {
+		adapter->num_rx_queues = num_tcs;
+	} else {
+		u16 rss = min_t(u16, num_online_cpus(), 2);
+
+		switch (hw->api_version) {
+		case ixgbe_mbox_api_11:
+			adapter->num_rx_queues = rss;
+			adapter->num_tx_queues = rss;
+		default:
+			break;
+		}
+	}
+#else
 	if (num_tcs > 1)
 		adapter->num_rx_queues = num_tcs;
+#endif
 }
 
 /**
diff --git a/drivers/amazon/ixgbevf/kcompat.h b/drivers/amazon/ixgbevf/kcompat.h
index 71d82d1..bef50e8 100644
--- a/drivers/amazon/ixgbevf/kcompat.h
+++ b/drivers/amazon/ixgbevf/kcompat.h
@@ -2345,6 +2345,9 @@ extern void _kc_pci_disable_link_state(struct pci_dev *dev, int state);
 #else /* < 2.6.26 */
 #include <linux/pci-aspm.h>
 #define HAVE_NETDEV_VLAN_FEATURES
+#ifndef PCI_EXP_LNKCAP_ASPMS
+#define PCI_EXP_LNKCAP_ASPMS 0x00000c00 /* ASPM Support */
+#endif /* PCI_EXP_LNKCAP_ASPMS */
 #endif /* < 2.6.26 */
 /*****************************************************************************/
 #if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27) )
@@ -2460,11 +2463,13 @@ extern void __kc_warn_slowpath(const char *file, const int line,
 })
 #endif /* WARN */
 #undef HAVE_IXGBE_DEBUG_FS
+#undef HAVE_IGB_DEBUG_FS
 #else /* < 2.6.27 */
 #define HAVE_TX_MQ
 #define HAVE_NETDEV_SELECT_QUEUE
 #ifdef CONFIG_DEBUG_FS
 #define HAVE_IXGBE_DEBUG_FS
+#define HAVE_IGB_DEBUG_FS
 #endif /* CONFIG_DEBUG_FS */
 #endif /* < 2.6.27 */
 
@@ -2513,6 +2518,9 @@ extern void _kc_pci_clear_master(struct pci_dev *dev);
 #define pci_clear_master(dev)	_kc_pci_clear_master(dev)
 #endif
 
+#ifndef PCI_EXP_LNKCTL_ASPMC
+#define  PCI_EXP_LNKCTL_ASPMC	0x0003	/* ASPM Control */
+#endif
 #else /* < 2.6.29 */
 #ifndef HAVE_NET_DEVICE_OPS
 #define HAVE_NET_DEVICE_OPS
@@ -3071,6 +3079,10 @@ do {								\
 #define u64_stats_fetch_retry_bh(a) (0)
 #define u64_stats_fetch_begin_bh(a) (0)
 
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,1))
+#define HAVE_8021P_SUPPORT
+#endif
+
 #else /* < 2.6.36 */
 
 
@@ -3482,6 +3494,19 @@ extern void _kc_skb_add_rx_frag(struct sk_buff *, int, struct page *,
 
 /******************************************************************************/
 #if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0) )
+#ifndef ADVERTISED_40000baseKR4_Full
+/* these defines were all added in one commit, so should be safe
+ * to trigger activiation on one define
+ */
+#define SUPPORTED_40000baseKR4_Full	(1 << 23)
+#define SUPPORTED_40000baseCR4_Full	(1 << 24)
+#define SUPPORTED_40000baseSR4_Full	(1 << 25)
+#define SUPPORTED_40000baseLR4_Full	(1 << 26)
+#define ADVERTISED_40000baseKR4_Full	(1 << 23)
+#define ADVERTISED_40000baseCR4_Full	(1 << 24)
+#define ADVERTISED_40000baseSR4_Full	(1 << 25)
+#define ADVERTISED_40000baseLR4_Full	(1 << 26)
+#endif
 /**
  * mmd_eee_cap_to_ethtool_sup_t
  * @eee_cap: value of the MMD EEE Capability register
@@ -3716,12 +3741,7 @@ static inline int __kc_pci_vfs_assigned(struct pci_dev *dev)
 }
 #endif
 #define pci_vfs_assigned(dev) __kc_pci_vfs_assigned(dev)
-#else /* >= 3.10.0 */
-#define HAVE_ENCAP_TSO_OFFLOAD
-#endif /* >= 3.10.0 */
 
-/*****************************************************************************/
-#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0) )
 #ifndef VLAN_TX_COOKIE_MAGIC
 static inline struct sk_buff *__kc__vlan_hwaccel_put_tag(struct sk_buff *skb,
 							 u16 vlan_tci)
@@ -3735,6 +3755,9 @@ static inline struct sk_buff *__kc__vlan_hwaccel_put_tag(struct sk_buff *skb,
 #define __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci) \
 	__kc__vlan_hwaccel_put_tag(skb, vlan_tci)
 #endif
-#endif /* < 3.11.0 */
+
+#else /* >= 3.10.0 */
+#define HAVE_ENCAP_TSO_OFFLOAD
+#endif /* >= 3.10.0 */
 
 #endif /* _KCOMPAT_H_ */
-- 
2.7.4

